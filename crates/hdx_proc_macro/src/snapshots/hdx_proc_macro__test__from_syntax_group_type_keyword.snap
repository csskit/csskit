---
source: crates/hdx_proc_macro/src/test.rs
expression: pretty
---
#[derive(Debug, PartialEq, Clone, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize), serde())]
enum Foo {
    Length(Length),
    LineThrough,
}
#[automatically_derived]
impl<'a> ::hdx_parser::Peek<'a> for Foo {
    fn peek(parser: &mut ::hdx_parser::Parser<'a>) -> ::hdx_parser::Option<Self> {
        use ::hdx_parser::Peek;
        parser
            .peek::<Length>()
            .or_else(|| parser.peek::<::hdx_parser::token::Ident>())
            .or_else(|| None)
    }
}
#[automatically_derived]
impl<'a> ::hdx_parser::Parse<'a> for Foo {
    fn parse(parser: &mut ::hdx_parser::Parser<'a>) -> ::hdx_parser::Result<Self> {
        use ::hdx_parser::Parse;
        if let Some(token) = parser.peek::<::hdx_parser::token::Ident>() {
            parser.next();
            Ok(
                match parser.parse_atom_lower(token) {
                    ::hdx_atom::atom!("line-through") => Self::LineThrough,
                    atom => {
                        Err(
                            ::hdx_parser::diagnostics::UnexpectedIdent(
                                atom,
                                token.span(),
                            ),
                        )?
                    }
                },
            )
        } else if parser.peek::<Length>().is_some() {
            let val = parser.parse::<Length>()?;
            if 1f32 > val.into() {
                return Err(
                    ::hdx_parser::diagnostics::NumberTooSmall(1f32, parser.span()),
                )?;
            }
            Ok(Self::Length(val))
        } else {
            let token = parser.peek_next();
            Err(::hdx_parser::diagnostics::Unexpected(token, token.span()))?
        }
    }
}
#[automatically_derived]
impl<'a> ::hdx_writer::WriteCss<'a> for Foo {
    fn write_css<W: ::hdx_writer::CssWriter>(
        &self,
        sink: &mut W,
    ) -> ::hdx_writer::Result {
        use ::hdx_writer::WriteCss;
        match self {
            Self::Length(inner) => {
                inner.write_css(sink)?;
            }
            Self::LineThrough => {
                ::hdx_atom::atom!("line-through").write_css(sink)?;
            }
        }
        Ok(())
    }
}
